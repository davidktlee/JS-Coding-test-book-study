**약간의 요약과 제 생각이 함께 작성되어 있습니다.**

# 06.스택

## 스택 개념

먼저 들어간 것이 마지막에 나오는 규칙을 후입선출 또는 LIFO(Last In First Out)이라고 한다.  
이때 스택에 삽입하는 연산을 **푸시**, 꺼내는 연산을 **팝**이라 한다.

## 스택의 정의

### 스택의 ADT

ADT란 한국어로 추상 자료형으로 인터페이스만 있고 실제로 구현은 되지 않은 자료 구조형이다.

스택에는 푸시, 팝, 가득 찼는지 확인, 비었는지 확인과 같은 연산을 정의해야 한다.

그리고 최근에 삽입한 데이터의 위치를 저장할 변수인 탑도 있어야 한다.

![사진](https://github.com/user-attachments/assets/dbdd5c84-262b-4dab-8281-041343da6f54)

## 스택 구현하기

```javascript
const stack = [] // 스택 초기화
const maxSize = 10 // 스택 최대 크기

function isFull(stack) {
  // 스택이 가득 찼는지 확인
  return stack.length === maxSize
}

function isEmpty(stack) {
  return stack.length === 0
}

function push(stack, item) {
  if (isFull(stack)) {
    console.log('스택이 가득 찼습니다.')
  } else {
    stack.push(item)
    console.log('데이터가 추가되었습니다.')
  }
}

function pop(stack) {
  if (isEmpty(stack)) {
    console.log('스택이 비어있습니다.')
    return null
  } else {
    return stack.pop()
  }
}
```

그러나 자바스크립트의 배열은 크기를 동적으로 관리하고 push나 pop도 구현되어 있으므로 isFull과 push, pop 메서드는 따로 구현해주지 않아도 된다.

## 몸풀기 문제

### 문제 1

열린 괄호나 닫힌 괄호가 마구 뒤섞인 문자열을 받아서 소괄호가 정상으로 열고 닫혔는지 solution 함수를 구현해라.  
만약 정상적으로 열고 닫혔다면 true를 아니라면 false를 반환해라.

**제약 조건**

- 열린 괄호는 자신과 가장 가까운 닫힌 괄호를 만나면 상쇄됩니다.
- 상쇄 조건은 열린 괄호가 먼저 와야하고, 열린 괄호와 닫힌 괄호사이에 아무것도 없어야합니다.
- 더 상쇄할 괄호가 없을 때까지 상쇄를 반복합니다.

**입출력의 예**
|s|반환값|
|:--|:--|
|(())()|true|
|((())()|false|

**내 문제 분석**

열린 괄호가 나왔을 때 stack에 푸시하고 닫힌 괄호가 나오면 stack에서 뺀다.
stack에 아무것도 없는데 닫힌 괄호가 나왔을 경우 false를 리턴한다.
마지막에 stack에 남은 요소가 있으면 false를 리턴한다.

**답**

```javascript
function solution(s) {
  const stack = []
  for (let i = 0; i < s.length; i++) {
    if (s[i] === '(') {
      stack.push(s[i])
    } else {
      if (!stack.length) return false
      else stack.pop()
    }
  }

  return !!stack.length
}
solution('((())()')
```

시간 복잡도는 s를 순회하며 괄호의 쌍을 확인하므로 O(N)이다.

### 문제2

10진수를 입력받아 2진수로 변환해 반환하는 solution 함수를 구현해라.

**제약 조건**
decimal은 1이상 10억 미만의 자연수

**입출력의 예**
|decimal|반환값|
|:--|:--|
|10|1010|
|27|11011|
|12345|11000000111001

**문제 분석**
10진수를 2진수로 변환하는 법은

1. 10진수 N을 2로 나눈 나머지 값을 저장하고, N은 2로 나눔
2. 몫이 0이 아니라면 나머지를 버리고 다시 1을 수행
3. 모든 과정이 끝나고 1에서 저장한 수를 뒤부터 순서대로 가져와 풀기

**답**

```javascript
function solution(decimal) {
  const stack = []

  while (decimal > 0) {
    stack.push(decimal % 2)
    decimal = Math.floor(decimal / 2)
  }
  console.log(stack.join(''))
}
solution(27)
```

시간 복잡도는 N이 1이 될 때까지 2로 계속 나누므로 O(logN)이다.
